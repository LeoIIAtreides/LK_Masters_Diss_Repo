from alive_progress import alive_bar
from Secrets import TOKEN
from twarc import Twarc2, expansions
import datetime
import json
import pandas as pd
import logging

# ND: Instead of importing a single tweeterid you want the whole list of userids.
# OR say Value_Counts is in a file called value_counts_file...
# import Value_Counts from value_counts_file
# and then run Value_Counts here and get the users list object that way.
import tweeterid

# Set up logging to print to console
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler()],
)

logger = logging.getLogger(__name__)



def get_users():
    data = pd.read_csv("Value_Count_Data.csv")
    data = data.loc[data["counts"] >= 5 ]
    bad_accounts = ['115123902', '138418838']
    data = data[~data.unique_values.isin(bad_accounts)]
    return data['unique_values'].tolist()



# Replace your bearer token below
client = Twarc2(bearer_token=TOKEN)

# ND: First, I've changed Twitter_Handle so it takes a tweeterid as an argument.
# This means you have to explicitly tell it the input id by going Twitter_Handle(user_id)
def Twitter_Handle(user):
    T_Handle = tweeterid.id_to_handle(user)
    X_Handle = T_Handle.lstrip("@")
    return X_Handle


# ND: I've also changed this so it takes the user_handle which is the output returned by Twitter_Handle
def User_Request(handle):
    # Specify the start time in UTC for the time period you want Tweets from
    start_time = datetime.datetime(2020, 11, 5, 0, 0, 0, 0, datetime.timezone.utc)

    # Specify the end time in UTC for the time period you want Tweets from
    end_time = datetime.datetime(2020, 12, 2, 0, 0, 0, 0, datetime.timezone.utc)

    file_name = "User_Lookup_Data_2.0.json"

    # This timeline functions gets the Tweet timeline for a specified user
    user_timeline = client.timeline(
        user=handle, start_time=start_time, end_time=end_time
    )

    # Twarc returns all Tweets for the criteria set above, so we page through the results
    for page in user_timeline:
        result = expansions.flatten(page)
        # We will open the file and append one JSON object per new line
        with open(file_name, "a+") as filehandle:
            for tweet in result:
                filehandle.write("%s\n" % json.dumps(tweet))


# ND: Now, the trick for reusing these is to define a function that wraps up the
# two main functions you need to run for each person.
# Then use a for-loop to go through each person in the list `users`.
# This involves passing the `users` object defined on Line 18 above to the function.
# This is also why we've specified that Twitter_Handle and User_Request take arguments
# instead of using 'global variables' (which is what tweeterid was before.)

def get_timelines(users):
    # Start the for loop...
    with alive_bar(len(users)) as bar:     
        for user in users:
            # Do this in a try-except statement so that if it fails for just one person then it
            # won't stop running at person 499/500
            try:
                # Pass the username to Twitter_Handle
                handle = Twitter_Handle(user)
                # Pass the cleaned handle to User_Request
                User_Request(handle)
                logger.info("collected user {}".format(user))
                # Once complete, it will move to the next user in the list
            except Exception as e:
                # If an error is raised for some reason (hopefully it won't be!)....
                # This prints a message with the user dynamically entered into the string print statement
                logger.error("Exception raised for user: {}".format(user))
                # Also print what the error was - good to know!
                print(e.message, e.args)
                # Now it will carry on to the next user without quitting the for-loop.
            bar()     

if __name__ == "__main__":
    # ND: You need an object called 'users' which contains the list of users returned
    # by Value_Count (?).
    # This might be generated by users = Value_Count(.....)
    users = get_users()
    get_timelines(users)
