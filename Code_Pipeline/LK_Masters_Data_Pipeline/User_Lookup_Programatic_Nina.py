from Secrets import TOKEN
from twarc import Twarc2, expansions
import datetime
import json

# ND: Instead of importing a single tweeterid you want the whole list of userids.
# OR say Value_Counts is in a file called value_counts_file...
# import Value_Counts from value_counts_file
# and then run Value_Counts here and get the users list object that way.
import tweeterid


# Replace your bearer token below
client = Twarc2(bearer_token=TOKEN)

# ND: First, I've changed Twitter_Handle so it takes a tweeterid as an argument.
# This means you have to explicitly tell it the input id by going Twitter_Handle(user_id)
def Twitter_Handle(tweeterid):
    T_Handel = tweeterid.id_to_handle("<USER_ID_HERE>")
    X_Handel = T_Handel.lstrip("@")
    return X_Handel


# ND: I've also changed this so it takes the user_handle which is the output returned by Twitter_Handle
def User_Request(handle):
    # Specify the start time in UTC for the time period you want Tweets from
    start_time = datetime.datetime(2020, 11, 5, 0, 0, 0, 0, datetime.timezone.utc)

    # Specify the end time in UTC for the time period you want Tweets from
    end_time = datetime.datetime(2020, 12, 2, 0, 0, 0, 0, datetime.timezone.utc)

    # File to write tweets to
    # ND: If you wanted each user to be saved in a different file then you could do something like
    # file_name = "User_Lookup_Data_" + handle + ".json"
    # This would create a dynamic file name.
    file_name = "User_Lookup_Data.json"

    # This timeline functions gets the Tweet timeline for a specified user
    user_timeline = client.timeline(
        user=handle, start_time=start_time, end_time=end_time
    )

    # Twarc returns all Tweets for the criteria set above, so we page through the results
    for page in user_timeline:
        result = expansions.flatten(page)
        # We will open the file and append one JSON object per new line
        with open(file_name, "a+") as filehandle:
            for tweet in result:
                filehandle.write("%s\n" % json.dumps(tweet))


# ND: Now, the trick for reusing these is to define a function that wraps up the
# two main functions you need to run for each person.
# Then use a for-loop to go through each person in the list `users`.
# This involves passing the `users` object defined on Line 18 above to the function.
# This is also why we've specified that Twitter_Handle and User_Request take arguments
# instead of using 'global variables' (which is what tweeterid was before.)
def get_timelines(users):
    # Start the for loop...
    for user in users:
        # Do this in a try-except statement so that if it fails for just one person then it
        # won't stop running at person 499/500
        try:
            # Pass the username to Twitter_Handle
            handle = Twitter_Handle(user)
            # Pass the cleaned handle to User_Request
            User_Request(handle)
            # Once complete, it will move to the next user in the list
        except Exception as e:
            # If an error is raised for some reason (hopefully it won't be!)....
            # This prints a message with the user dynamically entered into the string print statement
            print("Exception raised for user: {}".format(user))
            # Also print what the error was - good to know!
            print(e.message, e.args)
            # Now it will carry on to the next user without quitting the for-loop.


if __name__ == "__main__":
    # ND: You need an object called 'users' which contains the list of users returned
    # by Value_Count (?).
    # This might be generated by users = Value_Count(.....)
    users = ["user1", "user2"]

    get_timelines(users)
